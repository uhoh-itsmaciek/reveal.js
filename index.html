<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>reveal.js - The HTML Presentation Framework</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->
  </head>

  <body>
    
    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
	<section>
	  <h1>EXPLAINING EXPLAIN</h1>
	  <h3>A Glimpse into the Twisted Mind of the Postgres Query Planner</h3>
	  <br/>
	  <p>
	    <small>by <a href="http://bitrotincarnate.com">Maciek Sakrejda</a> / <a href="https://twitter.com/uhoh_itsmaciek">@uhoh_itsmaciek</a></small>
	  </p>
	  <p>
	    <small>based heavily on Understanding EXPLAIN by Guillaum Lelarge / Dalibo</small>
	  </p>
	  <p>
	    <small>slides and photos <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/">Creative Commons BY-NC-SA</a></small>
	  </p>
	</section>
	<section>
	  <h2>Credits</h2>
	  <ul>
	    <li><a href="http://www.dalibo.org/_media/understanding_explain.pdf">Understanding EXPLAIN</a></li>
	    <li><a href="http://www.depesz.com/tag/unexplainable/">Explaining the Unexplainable</a></li>
	    <li><a href="http://postgresguide.com/performance/explain.html">EXPLAIN at postgresguide.com</a></li>
	  </ul>
	</section>
	<section>
	  <h2>defining EXPLAIN</h2>
	  <aside class="notes">
	    <ul>
	      <li>Utility command to describe how Postgres will execute a query</li>
	      <li>really powerful</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>What to EXPLAIN</h2>
	  <ul>
	    <li>Expensive Queries</li>
	    <li><code>pg_stat_statements</code></li>
	    <li>slow query logs</li>
	  </ul>
	  <p class="fragment">
	    <code>egrep 'duration: [0-9]{6}'</code>
	  </p>
	</section>
	<section>
	  <h2>The anatomy of an explanation</h2>
	  <img src="images/tree.jpg" style="height:500px"/>
	  <small>https://www.flickr.com/photos/asphericlens/</small>
	  <aside class="notes">
	    <ul>
	      <li>ties into how postgres executes a query plan</li>
	      <li>tree of plan nodes</li>
	      <li>pull-based iterator model</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>sample data</h2>
	  <pre><code data-trim>
CREATE TABLE foo (c1 integer, c2 text);
INSERT INTO foo
  SELECT i, md5(random()::text)
  FROM generate_series(1, 1000000) AS i;
	  </code></pre>
	</section>
	<section>
	  <h2>our first explain</h2>
	  <pre><code data-trim>
EXPLAIN SELECT * FROM foo;
	    </code>
                         QUERY PLAN
--------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..18584.82 rows=1025082 width=36)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>not real units</li>
	      <li>sequential scan</li>
	      <li>startup cost 0.00</li>
	      <li>total cost 18584.82</li>
	      <li>rows count estimate 1025082</li>
	      <li>width 36</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>analyze</h2>
	  <pre><code data-trim>
ANALYZE foo; EXPLAIN SELECT * FROM foo;
	    </code>
ANALYZE
                          QUERY PLAN                          
--------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
(1 row)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>analyze gathers system statistics</li>
	      <li>samples 300 * default_statistics_target rows</li>
	      <li>tracks most common values</li>
	      <li>distribution histogram</li>
	      <li>null fraction</li>
	      <li>stores them in pg_statistic table</li>
	      <li>simplified view in pg_stats</li>
	      <li>used to discriminate between query plans</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>Stats are in the catalog</h2>
	  <pre><code data-trim>
SELECT
  sum(avg_width) AS width, reltuples,
  relpages * current_setting('seq_page_cost')::float4 +
    reltuples * current_setting('cpu_tuple_cost')::float4
    AS total_cost
FROM
  pg_class INNER JOIN pg_stats ON tablename = relname
WHERE
  relname = 'foo' GROUP BY 2, 3;
	    </code>
 width | reltuples | total_cost 
-------+-----------+------------
    37 |     1e+06 |      18334
(1 row)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>stats are in the catalog</li>
	      <li>no magic</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>explain analyze</h2>
	  <pre><code data-trim>
EXPLAIN ANALYZE SELECT * FROM foo;
	    </code>
                       QUERY PLAN                                                   
--------------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
                    (actual time=0.007..66.319 rows=1000000 loops=1)
 Planning time: 0.026 ms
 Execution time: 92.861 ms
(3 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>actually runs the query!</li>
	      <li>real units: milliseconds</li>
	      <li>expected / actual discrepancies in row counts: analyze</li>
	      <li>can still run on queries that modify data with rollback</li>
	      <li>far more useful when diagnosing perf problems</li>
	      <li>run twice to check caching impact</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>explain options!</h2>
	  <pre><code data-trim>
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM foo;
	    </code>
                     QUERY PLAN                                                   
--------------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
                    (actual time=0.006..67.787 rows=1000000 loops=1)
   Buffers: shared hit=8334
 Planning time: 0.019 ms
 Execution time: 99.961 ms
(4 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>buffers includes i/o information</li>
	      <li>"hit": found in postgres buffer pool</li>
	      <li>"read": read from os page cache or disk</li>
	      <li>verbose option also exists; not terribly useful</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>caching</h2>
	  <pre><code data-trim>
$ sudo service postgresql stop
$ sync
$ echo 3 | sudo tee /proc/sys/vm/drop_caches
$ sudo service postgresql start
	  </code></pre>
	  <aside class="notes">
	    this is how to drop caches on ubuntu
	  </aside>
	</section>
	<section>
	  <h2>caching</h2>
	  <pre><code data-trim>
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM foo;
	    </code>
                        QUERY PLAN
--------------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
                   (actual time=0.257..143.518 rows=1000000 loops=1)
   Buffers: shared read=8334
 Planning time: 3.267 ms
 Execution time: 182.555 ms
(4 rows)
	  </pre>
	  <aside class="notes">
	    buffers hit -> buffers read
	  </aside>
	</section>
	<section>
	  <h2>caching</h2>
	  <pre><code data-trim>
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM foo;
	    </code>
                        QUERY PLAN                                 
-------------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
                   (actual time=0.096..80.790 rows=1000000 loops=1)
   Buffers: shared hit=32 read=8302
 Planning time: 0.048 ms
 Execution time: 114.771 ms
(4 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>re-running the query, only 32 buffers hit</li>
	      <li>because postgres avoids thrashing the cache on seq scans</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>filtering</h2>
	  <pre><code data-trim>
EXPLAIN SELECT * FROM foo WHERE c1 > 500;
	    </code>
                         QUERY PLAN                          
-------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..20834.00 rows=999478 width=37)
   Filter: (c1 > 500)
(2 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>no indexes, so still has to be seq scan</li>
	      <li>throws away rows which don't match filter while scanning</li>
	      <li>higher cost due to having to check filter for each row</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>stats still in catalog</h2>
	  <pre><code data-trim>
SELECT
  relpages * current_setting('seq_page_cost')::float4 +
    reltuples * current_setting('cpu_tuple_cost')::float4 +
    reltuples * current_setting('cpu_operator_cost')::float4
    AS total_cost
FROM
  pg_class
WHERE
  relname = 'foo';
	    </code>
 total_cost 
------------
      20834
(1 row)
	  </pre>
	</section>
	<section>
	  <h2>would an index help?</h2>
	  <pre><code data-trim>
CREATE INDEX ON foo(c1);
EXPLAIN SELECT * FROM foo WHERE c1 > 500;
	    </code>
CREATE INDEX
                         QUERY PLAN                          
-------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..20834.00 rows=999478 width=37)
   Filter: (c1 > 500)
(2 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>no</li>
	      <li>1M row table; we're only discarding 500 rows</li>
	      <li>still need to read most of table</li>
	      <li>faster if done sequentially</li>
	      <li>index not helpful for >50%</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>you can't tell me what to do</h2>
	  <pre><code data-trim>
SET enable_seqscan TO off;
EXPLAIN SELECT * FROM foo WHERE c1 > 500;
SET enable_seqscan TO on;
	    </code>
SET
                  QUERY PLAN                                   
----------------------------------------------
 Index Scan using foo_c1_idx on foo
    (cost=0.42..36800.62 rows=999497 width=37)
   Index Cond: (c1 > 500)
(2 rows)
SET
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>bad idea</li>
	      <li>for each index entry, has to read corresponding page</li>
	      <li>first row, page 1; second row, page 1; third, still page 1</li>
	      <li>note that there are enable_* parameters for different access methods</li>
	      <li></li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>using the index</h2>
	  <pre><code data-trim>
EXPLAIN SELECT * FROM foo WHERE c1 < 500;
	    </code>
              QUERY PLAN                                
----------------------------------------
 Index Scan using foo_c1_idx on foo
    (cost=0.42..25.23 rows=503 width=37)
   Index Cond: (c1 < 500)
(2 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>works!</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>more complex filter</h2>
	  <pre><code data-trim>
EXPLAIN SELECT * FROM foo WHERE c1 < 500 AND c2 LIKE 'abcd%';
	    </code>
             QUERY PLAN                               
--------------------------------------
 Index Scan using foo_c1_idx on foo
    (cost=0.42..26.49 rows=1 width=37)
   Index Cond: (c1 < 500)
   Filter: (c2 ~~ 'abcd%'::text)
(3 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>index scan and filter</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>filter on just c2</h2>
	  <pre><code data-trim>
EXPLAIN ANALYZE SELECT * FROM foo WHERE c2 LIKE 'abcd%';
	    </code>
                      QUERY PLAN                                               
----------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..20834.00 rows=100 width=37)
                    (actual time=9.459..101.409 rows=12 loops=1)
   Filter: (c2 ~~ 'abcd%'::text)
   Rows Removed by Filter: 999988
 Planning time: 0.101 ms
 Execution time: 101.438 ms
(5 rows)
	  </pre>
	  <aside class="notes">
	    <ul>
	      <li>seq scan and filter</li>
	      <li>only 12 rows kept--index could help</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>indexing c2</h2>
	  <pre><code data-trim>
CREATE INDEX ON foo(c2 text_pattern_ops);
EXPLAIN ANALYZE SELECT * FROM foo WHERE c2 LIKE 'abcd%';
	    </code>
CREATE INDEX
                         QUERY PLAN                                                      
--------------------------------------------------------------------
 Bitmap Heap Scan on foo  (cost=4.60..62.88 rows=100 width=37)
                          (actual time=0.043..0.102 rows=12 loops=1)
   Filter: (c2 ~~ 'abcd%'::text)
   Heap Blocks: exact=12
   ->  Bitmap Index Scan on foo_c2_idx
                          (cost=0.00..4.58 rows=15 width=0)
                          (actual time=0.023..0.023 rows=12 loops=1)
         Index Cond: ((c2 ~>=~ 'abcd'::text)
                       AND (c2 ~<~ 'abce'::text))
 Planning time: 0.244 ms
 Execution time: 0.117 ms
(7 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>text_pattern ops: for substring comparisons</li>
	      <li>bitmap index scan: bit for each page</li>
	      <li>get pages which match these criteria; filter</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>covering index</h2>
	  <pre><code data-trim>
EXPLAIN ANALYZE SELECT c1 FROM foo WHERE c1 < 500;
	    </code>
                   QUERY PLAN                                                        
-------------------------------------------------
 Index Only Scan using foo_c1_idx on foo
    (cost=0.42..25.23 rows=503 width=4)
      (actual time=0.036..0.257 rows=499 loops=1)
   Index Cond: (c1 < 500)
   Heap Fetches: 499
 Planning time: 0.089 ms
 Execution time: 0.305 ms
(5 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>index only scan!</li>
	      <li>no need to go to heap at all</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>major scan nodes</h2>
	  <ul>
	    <li>sequential scan</li>
	    <li>index scan</li>
	    <li>bitmap index scan</li>
	    <li>index only scan</li>
	  </ul>
	</section>
	<section>
	  <h2>order by</h2>
	  <pre><code data-trim>
DROP INDEX foo_c1_idx;
EXPLAIN ANALYZE SELECT * FROM foo ORDER BY c1;
	    </code>
DROP INDEX
                       QUERY PLAN                                                      
------------------------------------------------------------------
 Sort  (cost=145337.34..147837.34 rows=1000000 width=37)
         (actual time=507.949..611.465 rows=1000000 loops=1)
   Sort Key: c1
   Sort Method: external merge  Disk: 45944kB
   ->  Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
             (actual time=0.006..77.289 rows=1000000 loops=1)
 Planning time: 0.082 ms
 Execution time: 643.839 ms
(6 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>external (disk) sort</li>
	      <li>not enough room to run it in memory</li>
	      <li>really expensive</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>order by</h2>
	  <pre><code data-trim>
SET work_mem = '128MB';
EXPLAIN ANALYZE SELECT * FROM foo ORDER BY c1;
	    </code>
SET
                        QUERY PLAN                                                      
------------------------------------------------------------
 Sort  (cost=117991.84..120491.84 rows=1000000 width=37)
         (actual time=234.874..268.844 rows=1000000 loops=1)
   Sort Key: c1
   Sort Method: quicksort  Memory: 102702kB
   ->  Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
             (actual time=0.014..74.361 rows=1000000 loops=1)
 Planning time: 0.078 ms
 Execution time: 296.311 ms
(6 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>in-memory sort</li>
	      <li>needs more memory than the on-disk sort</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>order by</h2>
	  <pre><code data-trim>
CREATE INDEX ON foo(c1);
EXPLAIN ANALYZE SELECT * FROM foo ORDER BY c1;
	    </code>
CREATE INDEX
                   QUERY PLAN                                                             
-----------------------------------------------------
 Index Scan using foo_c1_idx on foo
    (cost=0.42..34317.43 rows=1000000 width=37)
    (actual time=0.029..157.633 rows=1000000 loops=1)
 Planning time: 0.117 ms
 Execution time: 183.110 ms
(3 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>just follows the index</li>
	      <li>more expensive than a seq scan, but no need to sort</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>back to c2</h2>
	  <pre><code data-trim>
DROP INDEX foo_c2_idx;
EXPLAIN ANALYZE SELECT * FROM foo WHERE c2 LIKE 'ab%';
	    </code>
DROP INDEX
                     QUERY PLAN                                                 
------------------------------------------------------------------
 Seq Scan on foo  (cost=0.00..20834.00 rows=10101 width=37)
                    (actual time=0.033..117.064 rows=3935 loops=1)
   Filter: (c2 ~~ 'ab%'::text)
   Rows Removed by Filter: 996065
 Planning time: 0.086 ms
 Execution time: 117.215 ms
(5 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>back to seq scan and filter</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>limits</h2>
	  <pre><code data-trim>
EXPLAIN ANALYZE SELECT * FROM foo WHERE c2 LIKE 'ab%' LIMIT 10;
	    </code>
                        QUERY PLAN                                                  
-----------------------------------------------------------------
 Limit  (cost=0.00..20.63 rows=10 width=37)
          (actual time=0.024..0.211 rows=10 loops=1)
   ->  Seq Scan on foo  (cost=0.00..20834.00 rows=10101 width=37)
             (actual time=0.022..0.208 rows=10 loops=1)
         Filter: (c2 ~~ 'ab%'::text)
         Rows Removed by Filter: 1806
 Planning time: 0.043 ms
 Execution time: 0.221 ms
(6 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>still seq scan and filter</li>
	      <li>but only has to process ~1800 rows</li>
	      <li>before finding the 10 ~~ 'ab%'</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>joins</h2>
	  <pre><code data-trim>
CREATE TABLE bar(c1 integer, c2 boolean);
INSERT INTO bar
  SELECT i, i % 2 = 1
  FROM generate_series(1, 500000) AS i;
ANALYZE bar;
	    </code>
CREATE TABLE
INSERT 0 500000
ANALYZE
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>let's create another table</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>joins</h2>
	  <pre><code data-trim>
EXPLAIN ANALYZE SELECT * FROM foo INNER JOIN bar USING(c1);
	    </code>
                      QUERY PLAN                                                       
--------------------------------------------------------------------
 Hash Join  (cost=13463.00..49297.00 rows=500000 width=38)
              (actual time=175.712..891.262 rows=500000 loops=1)
   Hash Cond: (foo.c1 = bar.c1)
   ->  Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=37)
                   (actual time=0.006..65.207 rows=1000000 loops=1)
   ->  Hash  (cost=7213.00..7213.00 rows=500000 width=5)
                (actual time=119.472..119.472 rows=500000 loops=1)
         Buckets: 65536  Batches: 1  Memory Usage: 19532kB
         ->  Seq Scan on bar
                 (cost=0.00..7213.00 rows=500000 width=5)
                   (actual time=0.007..52.843 rows=500000 loops=1)
 Planning time: 0.231 ms
 Execution time: 904.222 ms
(8 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>hash join</li>
	      <li>hash all of left; hash right see what matches</li>
	      <li>only works for equality as join condition</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>joins</h2>
	  <pre><code data-trim>
CREATE INDEX ON bar(c1);
EXPLAIN ANALYZE SELECT * FROM foo INNER JOIN bar USING(c1);
	    </code>
CREATE INDEX
                       QUERY PLAN                                                               
----------------------------------------------------------
 Merge Join  (cost=1.77..39862.33 rows=500000 width=38)
    (actual time=0.021..273.464 rows=500000 loops=1)
   Merge Cond: (foo.c1 = bar.c1)
   ->  Index Scan using foo_c1_idx on foo
           (cost=0.42..34317.43 rows=1000000 width=37)
           (actual time=0.010..67.641 rows=500001 loops=1)
   ->  Index Scan using bar_c1_idx on bar
           (cost=0.42..15212.42 rows=500000 width=5)
           (actual time=0.008..71.350 rows=500000 loops=1)
 Planning time: 0.366 ms
 Execution time: 286.706 ms
(6 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>merge join</li>
	      <li>traverse two sorted sets in tandem</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>joins</h2>
	  <pre><code data-trim>
DELETE FROM bar WHERE c1 > 500; DROP INDEX bar_c1_idx; ANALYZE bar;
EXPLAIN ANALYZE SELECT * FROM foo INNER JOIN bar USING(c1);
	    </code>
DELETE 499500
DROP INDEX
ANALYZE
                        QUERY PLAN                                                             
------------------------------------------------------------------
 Merge Join  (cost=2240.97..2266.86 rows=500 width=38)
               (actual time=22.097..22.310 rows=500 loops=1)
   Merge Cond: (foo.c1 = bar.c1)
   ->  Index Scan using foo_c1_idx on foo
          (cost=0.42..34317.43 rows=1000000 width=37)
          (actual time=0.005..0.072 rows=501 loops=1)
   ->  Sort  (cost=2240.41..2241.66 rows=500 width=5)
             (actual time=22.089..22.109 rows=500 loops=1)
         Sort Key: bar.c1
         Sort Method: quicksort  Memory: 48kB
         ->  Seq Scan on bar (cost=0.00..2218.00 rows=500 width=5)
                (actual time=0.004..22.042 rows=500 loops=1)
 Planning time: 0.123 ms
 Execution time: 22.336 ms
(9 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>merge join</li>
	      <li>sometimes worth sorting the input</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>joins</h2>
	  <pre><code data-trim>
DELETE FROM foo WHERE c1 > 1000; ANALYZE foo;
EXPLAIN ANALYZE SELECT * FROM foo INNER JOIN bar USING(c1);
	    </code>
DELETE 999000
ANALYZE
                         QUERY PLAN                                                         
------------------------------------------------------------------
 Nested Loop  (cost=9.84..6939.13 rows=500 width=38)
                (actual time=0.015..1.871 rows=500 loops=1)
   ->  Seq Scan on bar  (cost=0.00..8.00 rows=500 width=5)
               (actual time=0.004..0.058 rows=500 loops=1)
   ->  Bitmap Heap Scan on foo  (cost=9.84..13.85 rows=1 width=37)
                       (actual time=0.003..0.003 rows=1 loops=500)
         Recheck Cond: (c1 = bar.c1)
         Heap Blocks: exact=500
         ->  Bitmap Index Scan on foo_c1_idx
               (cost=0.00..9.84 rows=1 width=0)
                 (actual time=0.002..0.002 rows=1 loops=500)
               Index Cond: (c1 = bar.c1)
 Planning time: 0.228 ms
 Execution time: 1.917 ms
(9 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>nested loop join</li>
	      <li>first row from left, each row from right</li>
	      <li>good for tiny amounts of data</li>
	      <li>sometimes picked by postgres when it has bad stats</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>joins</h2>
	  <pre><code data-trim>
EXPLAIN ANALYZE SELECT * FROM foo CROSS JOIN bar;
	    </code>
                          QUERY PLAN                                               
--------------------------------------------------------------------
 Nested Loop  (cost=0.00..29179.80 rows=2330000 width=42)
                (actual time=0.001..0.001 rows=0 loops=1)
   ->  Seq Scan on bar  (cost=0.00..33.30 rows=2330 width=5)
                   (actual time=0.001..0.001 rows=0 loops=1)
   ->  Materialize  (cost=0.00..24.00 rows=1000 width=37)
                      (never executed)
         ->  Seq Scan on foo  (cost=0.00..19.00 rows=1000 width=37)
                                  (never executed)
 Planning time: 0.041 ms
 Execution time: 0.018 ms
(6 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>nested loop join</li>
	      <li>only join type for cross join</li>
	      <li>materialize node!</li>
	      <li>often used for sorts</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>major join nodes</h2>
	  <ul>
	    <li>nested loop join</li>
	    <li>merge join</li>
	    <li>hash join</li>
	  </ul>
	  <aside class="notes">
	    <ul>
	      <li>nlj: small data, cross joins, bad stats</li>
	      <li>merge join: sorted input, nice for big datasets</li>
	      <li>hash join: only equality joins, but quick</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>inheritance</h2>
	  <pre><code data-trim>
CREATE TABLE baz(c1 timestamptz, c2 text);
CREATE TABLE baz_2015(CHECK(c1 BETWEEN '2015-01-01' AND '2015-12-31')) INHERITS (baz);
CREATE TABLE baz_2014(CHECK(c1 BETWEEN '2014-01-01' AND '2014-12-31')) INHERITS (baz);
CREATE TABLE baz_2013(CHECK(c1 BETWEEN '2013-01-01' AND '2013-12-31')) INHERITS (baz);
INSERT INTO baz_2015 SELECT now() - i * interval '1 day', 'line '||i
  FROM generate_series(1, 100) AS i;
INSERT INTO baz_2014 SELECT now() - interval '1 year' - i * interval '1 day', 'line '||i
  FROM generate_series(1, 100) AS i;
 INSERT INTO baz_2013 SELECT now() - interval '2 years' - i * interval '1 day', 'line '||i
  FROM generate_series(1, 100) AS i;
	    </code>
CREATE TABLE
CREATE TABLE
CREATE TABLE
CREATE TABLE
INSERT 0 100
INSERT 0 100
INSERT 0 100
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>useful for partitioning</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>inheritance</h2>
	  <pre><code data-trim>
EXPLAIN ANALYZE SELECT * FROM baz
  WHERE c1 BETWEEN '2015-03-29' AND '2015-04-02';
	    </code>
                    QUERY PLAN                                                                  
--------------------------------------------------------------
 Append  (cost=0.00..2.50 rows=5 width=20)
           (actual time=0.008..0.013 rows=4 loops=1)
   ->  Seq Scan on baz  (cost=0.00..0.00 rows=1 width=40)
                  (actual time=0.000..0.000 rows=0 loops=1)
         Filter: ((c1 >= '2015-03-29 00:00:00'::timestamptz)
              AND (c1 <= '2015-04-02 00:00:00'::timestamptz))
   ->  Seq Scan on baz_2015  (cost=0.00..2.50 rows=4 width=15)
                     (actual time=0.008..0.012 rows=4 loops=1)
         Filter: ((c1 >= '2015-03-29 00:00:00'::timestamptz)
              AND (c1 <= '2015-04-02 00:00:00'::timestamptz))
         Rows Removed by Filter: 96
 Planning time: 0.237 ms
 Execution time: 0.026 ms
(8 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>append node</li>
	      <li>seq scan on parent</li>
	      <li>and only the child matching constraints</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>inheritance</h2>
	  <pre><code data-trim>
CREATE INDEX ON baz_2015(c1);
EXPLAIN ANALYZE SELECT * FROM baz WHERE c1 = '2015-04-01';
	    </code>
CREATE INDEX
                     QUERY PLAN                                                            
---------------------------------------------------------------
 Append  (cost=0.00..118.55 rows=27 width=39)
       (actual time=1.947..1.947 rows=0 loops=1)
   ->  Seq Scan on baz  (cost=0.00..110.25 rows=26 width=40)
                   (actual time=1.937..1.937 rows=0 loops=1)
         Filter: (c1 = '2015-04-01 00:00:00'::timestamptz)
   ->  Index Scan using baz_2015_c1_idx on baz_2015
          (cost=0.28..8.30 rows=1 width=15)
            (actual time=0.010..0.010 rows=0 loops=1)
         Index Cond: (c1 = '2015-04-01 00:00:00'::timestamptz)
 Planning time: 0.226 ms
 Execution time: 1.978 ms
(7 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>planner will pick the right indexes for child tables</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>aggregates</h2>
	  <pre><code data-trim>
EXPLAIN SELECT COUNT(*) FROM foo;
	    </code>
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate  (cost=21.50..21.51 rows=1 width=0)
   ->  Seq Scan on foo  (cost=0.00..19.00 rows=1000 width=0)
(2 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>simplest aggregate node</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>aggregates</h2>
	  <pre><code data-trim>
EXPLAIN SELECT max(c2) FROM foo;
	    </code>
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate  (cost=21.50..21.51 rows=1 width=0)
   ->  Seq Scan on foo  (cost=0.00..19.00 rows=1000 width=0)
(2 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>other aggregates can use the agg node as well</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>aggregates</h2>
	  <pre><code data-trim>
CREATE INDEX ON foo(c2);
EXPLAIN ANALYZE SELECT max(c2) FROM foo;
	    </code>
CREATE INDEX
                      QUERY PLAN                                                                       
----------------------------------------------------------------
 Result  (cost=0.50..0.51 rows=1 width=0)
         (actual time=0.028..0.028 rows=1 loops=1)
   InitPlan 1 (returns $0)
     ->  Limit  (cost=0.42..0.50 rows=1 width=33)
                (actual time=0.027..0.027 rows=1 loops=1)
           ->  Index Only Scan Backward using foo_c2_idx on foo
                  (cost=0.42..79676.41 rows=1000000 width=33)
                  (actual time=0.025..0.025 rows=1 loops=1)
                 Index Cond: (c2 IS NOT NULL)
                 Heap Fetches: 1
 Planning time: 0.160 ms
 Execution time: 0.047 ms
(8 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>but they can be smarter</li>
	      <li>go to the end of the index, go backward, take first result</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>aggregates</h2>
	  <pre><code data-trim>
DROP INDEX foo_c2_idx;
EXPLAIN ANALYZE SELECT c2, count(*) FROM foo GROUP BY c2;
	    </code>
DROP INDEX
                              QUERY PLAN                                                         
-------------------------------------------------------------------
 GroupAggregate  (cost=145337.34..162815.50 rows=997816 width=33)
             (actual time=3609.391..5459.632 rows=999782 loops=1)
   Group Key: c2
   ->  Sort  (cost=145337.34..147837.34 rows=1000000 width=33)
           (actual time=3609.382..5236.497 rows=1000000 loops=1)
         Sort Key: c2
         Sort Method: external merge  Disk: 41960kB
         ->  Seq Scan on foo
                 (cost=0.00..18334.00 rows=1000000 width=33)
                 (actual time=0.012..106.451 rows=1000000 loops=1)
 Planning time: 0.164 ms
 Execution time: 5492.032 ms
(8 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>group agg requires sorted input</li>
	      <li>external sort here; expensive</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>aggregates</h2>
	  <pre><code data-trim>
SET work_mem = '128MB';
EXPLAIN ANALYZE SELECT c2, count(*) FROM foo GROUP BY c2;
	    </code>
SET
                         QUERY PLAN                                                      
-------------------------------------------------------------------
 HashAggregate  (cost=23334.00..33312.16 rows=997816 width=33)
            (actual time=598.006..913.493 rows=999782 loops=1)
   Group Key: c2
   ->  Seq Scan on foo  (cost=0.00..18334.00 rows=1000000 width=33)
                  (actual time=0.011..109.682 rows=1000000 loops=1)
 Planning time: 0.044 ms
 Execution time: 963.061 ms
(5 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>hash agg</li>
	      <li>needs more work mem</li>
	      <li>like hash joinm but for aggregation</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>aggregates</h2>
	  <pre><code data-trim>
RESET work_mem;
CREATE INDEX ON foo(c2);
EXPLAIN ANALYZE SELECT c2, count(*) FROM foo GROUP BY c2;
	    </code>
RESET
CREATE INDEX
                         QUERY PLAN                                                                  
-------------------------------------------------------------
 GroupAggregate  (cost=0.42..92152.49 rows=997816 width=33)
             (actual time=0.024..781.881 rows=999782 loops=1)
   Group Key: c2
   ->  Index Only Scan using foo_c2_idx on foo
                (cost=0.42..77174.33 rows=1000000 width=33)
            (actual time=0.019..508.656 rows=1000000 loops=1)
         Heap Fetches: 1000000
 Planning time: 0.115 ms
 Execution time: 808.639 ms
(6 rows)
          </pre>
	  <aside class="notes">
	    <ul>
	      <li>merge join</li>
	      <li>traverse two sorted sets in tandem</li>
	    </ul>
	  </aside>
	</section>
	<section>
	  <h2>major aggregate nodes</h2>
	  <ul>
	    <li>aggregate</li>
	    <li>group aggregate</li>
	    <li>hash aggregate</li>
	  </ul>
	</section>
	<section>
	  <h2>conclusion</h2>
	  <ul>
	    <li>Postgres planner is pretty sweet</li>
	    <li>EXPLAIN gives insight into what planner is doing</li>
	    <li>work_mem changes and indexes can give you better plans</li>
	  </ul>
	</section>
	<section>
	  <h2>questions</h2>
	</section>
      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
      { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'plugin/zoom-js/zoom.js', async: true },
      { src: 'plugin/notes/notes.js', async: true }
      ]
      });

    </script>

  </body>
</html>
